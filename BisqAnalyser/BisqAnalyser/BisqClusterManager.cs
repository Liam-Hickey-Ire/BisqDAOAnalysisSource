using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using Io.Bisq.Protobuffer;
using BisqAnalyser.ClusterObjects;

namespace BisqAnalyser
{
    class BisqClusterManager
    {
        static Dictionary<long, Cluster> m_clusterMap = new Dictionary<long, Cluster>();
        static Dictionary<long, long> m_addressMap = new Dictionary<long, long>();

        /// <summary>
        /// Functions creates address clusters using Bisq DAO specific address clustering heuristic
        /// </summary>
        /// <param name="bisqData">BisqData object</param>
        /// <param name="clusterData">ClusterData object</param>
        /// <returns>Dictionary containing clusters generated by heuristic</returns>
        public static Dictionary<long, Cluster> CreateBisqSpecificClusters(BisqData bisqData, ClusterData clusterData)
        {
            int idCounter = 0;
            int uniqueCounter = -1;
            foreach (Transaction tx in bisqData.Transactions.Values)
            {
                int txType = tx.BisqType;
                if(254 != txType && 255 != txType && 0 != txType) // We don't cluster invalid, irregular, or genesis transaction types
                {
                    Cluster cluster = new Cluster();
                    cluster.Id = idCounter;

                    // Left Side Transaction
                    foreach (TransactionInput input in tx.Inputs)
                    {
                        TransactionOutput output = input.TransactionOutput;
                        CheckOutput(output, cluster, clusterData);
                    }

                    // Right Side Transaction
                    bool skipFirstOrdinal = 1 == txType; // We skip the first ordinal output for BSQ transfer transactions
                    foreach(TransactionOutput output in tx.Outputs)
                    {
                        if(skipFirstOrdinal) // If we have a transfer transaction, we create a cluster containing a single address for the non-BSQ output
                        {
                            long addressId = output.AddressId;
                            if (!m_addressMap.ContainsKey(addressId) && -1 != addressId)
                            {
                                AddSingleAddressCluster(uniqueCounter, addressId, clusterData);
                                --uniqueCounter; // using negative IDs for time being until better solution is obvious
                            }
                            skipFirstOrdinal = false;
                            continue;
                        }
                        CheckOutput(output, cluster, clusterData);
                    }
                    if (cluster.Addresses.Count != 0)
                    {
                        m_clusterMap[idCounter] = cluster;
                    }
                    ++idCounter;
                }
                else
                {
                    idCounter = HandleUnusualTransaction(tx, idCounter, clusterData);
                }
            }
            return m_clusterMap;
        }

        /// <summary>
        /// Function adds addresses from a tx output to an address cluster, also merges clusters where applicable
        /// </summary>
        /// <param name="output">Tx output to check for addresses to cluster</param>
        /// <param name="cluster">Cluster to which addresses should be added</param>
        /// <param name="clusterData">Cluster data containing info regarding all addresses</param>
        private static void CheckOutput(TransactionOutput output, Cluster cluster, ClusterData clusterData)
        {
            long addressId = output.AddressId;
            long currentId = cluster.Id;
            if (addressId != -1) // -1 means that this output does not have an address
            {
                if (!m_addressMap.ContainsKey(addressId))
                {
                    m_addressMap[addressId] = cluster.Id;
                    Address newAddress = clusterData.Addresses[addressId];
                    newAddress.Id = addressId;
                    cluster.Addresses.Add(addressId, newAddress);
                }
                else
                {
                    long oldClusterId = m_addressMap[addressId];
                    if (oldClusterId != currentId)
                    {
                        Cluster oldCluster = m_clusterMap[oldClusterId];
                        MergeClusters(cluster, oldCluster);
                    }
                }
            }
        }

        /// <summary>
        /// Function merges two clusters that share an address
        /// </summary>
        /// <param name="a">Address cluster</param>
        /// <param name="b">Address cluster</param>
        private static void MergeClusters(Cluster a, Cluster b)
        {
            foreach (var address in b.Addresses)
            {
                a.Addresses.Add(address.Key, address.Value);
                m_addressMap[address.Key] = a.Id;
                m_clusterMap.Remove(b.Id);
            }
        }

        /// <summary>
        /// Function creates a single cluster for each address found in an unusual transaction (genesis, irregular or invalid)
        /// </summary>
        /// <param name="tx">Transaction to which to apply clustering heuristic</param>
        /// <param name="idCounter">Cluster id counter</param>
        /// <param name="clusterData"></param>
        /// <returns></returns>
        private static int HandleUnusualTransaction(Transaction tx, int idCounter, ClusterData clusterData)
        {
            foreach (TransactionInput input in tx.Inputs)
            {
                TransactionOutput output = input.TransactionOutput;
                long addressId = output.AddressId;
                if (!m_addressMap.ContainsKey(addressId) && -1 != addressId)
                {
                    AddSingleAddressCluster(idCounter, addressId, clusterData);
                    ++idCounter;
                }
            }
            foreach (TransactionOutput output in tx.Outputs)
            {
                long addressId = output.AddressId;
                if (!m_addressMap.ContainsKey(addressId) && -1 != addressId)
                {
                    AddSingleAddressCluster(idCounter, addressId, clusterData);
                    ++idCounter;
                }
            }
            return idCounter;
        }

        /// <summary>
        /// Create a cluster containing a single address
        /// </summary>
        /// <param name="idCounter">Id to assign to the new cluster</param>
        /// <param name="addressId">address id to add to the new cluster</param>
        /// <param name="clusterData">Cluster data containing info regarding all addresses</param>
        private static void AddSingleAddressCluster(int idCounter, long addressId, ClusterData clusterData)
        {
            Cluster cluster = new Cluster();
            cluster.Id = idCounter;
            Address newAddress = clusterData.Addresses[addressId];
            newAddress.Id = addressId;
            cluster.Addresses.Add(addressId, newAddress);
            m_addressMap[addressId] = idCounter;
            m_clusterMap[idCounter] = cluster;
        }

        /// <summary>
        /// Adds a tag to each cluster based on tags found in Bisq proposals
        /// </summary>
        /// <param name="bisqData">BisqData obejct containg Bisq proposal transactions</param>
        /// <param name="proposalStore">ProposalStore object containing a tag for each proposal</param>
        public static void TagClustersFromProposals(BisqData bisqData, ProposalStore proposalStore)
        {
            Dictionary<string, string> hashToName = new Dictionary<string, string>();
            foreach(var proposal in proposalStore.Items)
            {
                string hash = proposal.Proposal.TxId;
                string name = proposal.Proposal.Name;
                hashToName.Add(hash, name);
            }

            foreach(Transaction tx in bisqData.Transactions.Values)
            {
                int txType = tx.BisqType;
                if(3 == txType || 4 == txType || 5 == txType) // Type 3 is a proposal, they have names attached
                {
                    string hash = tx.Hash;
                    foreach (TransactionInput input in tx.Inputs)
                    {
                        TransactionOutput output = input.TransactionOutput;
                        long addressId = output.AddressId;
                        if(-1 != addressId)
                        {
                            long clusterId = m_addressMap[addressId];
                            if(hashToName.ContainsKey(hash))
                            {
                                if (string.Empty == m_clusterMap[clusterId].Tag)
                                {
                                    m_clusterMap[clusterId].Tag = hashToName[hash];
                                }
                                else
                                {
                                    m_clusterMap[clusterId].Tag += "," + hashToName[hash];
                                }
                            }
                            else
                            {
                                Console.WriteLine();
                            }
                        }
                    }
                    foreach (TransactionOutput output in tx.Outputs)
                    {
                        long addressId = output.AddressId;
                        if (-1 != addressId)
                        {
                            long clusterId = m_addressMap[addressId];
                            if (hashToName.ContainsKey(hash))
                            {
                                if(string.Empty == m_clusterMap[clusterId].Tag)
                                {
                                    m_clusterMap[clusterId].Tag = hashToName[hash];
                                }
                                else
                                {
                                    m_clusterMap[clusterId].Tag += "," + hashToName[hash];
                                }
                            }
                            else
                            {
                                Console.WriteLine();
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Adds a tag to each cluster based on tags found in a JSON file
        /// </summary>
        /// <param name="clusterData">ClustersData object containing clusters for tagging</param>
        /// <param name="filepath">JSON tag file location</param>
        public static void TagClustersFromJson(ClusterData clusterData, string filepath)
        {
            using (StreamReader reader = new StreamReader(filepath))
            {
                string json = reader.ReadToEnd();
                var jsonObj = JsonConvert.DeserializeObject<Dictionary<string, List<string>>>(json);
                foreach (var tag in jsonObj)
                {
                    foreach(string addr in tag.Value)
                    {
                        string btcAddress = addr.Substring(1);
                        var kvPair = clusterData.Addresses.FirstOrDefault(x => Util.ByteArrayToBase58(Util.PrependByteVal(x.Value.Hash, (byte)(x.Value.Type == 0 ? 0 : 5))) == btcAddress);
                        if(kvPair.Value != null)
                        {
                            long clusterId = m_addressMap[kvPair.Value.Id];
                            if (string.Empty == m_clusterMap[clusterId].Tag)
                            {
                                m_clusterMap[clusterId].Tag = tag.Key;
                            }
                            else
                            {
                                m_clusterMap[clusterId].Tag += "," + tag.Key;
                            }
                        }

                    }
                }
            }
        }
    }
}
